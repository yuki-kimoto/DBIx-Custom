=encoding utf8

=head1 NAME

DBIx::Custom::Guide - DBIx::Custom Guide

=head1 GUIDE

B<This guide is now writing.>

L<DBIx::Custom> is the class to make easy to execute SQL.
This is L<DBI> wrapper class like L<DBIx::Class> or L<DBIx::Simple>.
You can do thing more easy than L<DBIx::Class>, more flexible
than L<DBIx::Simple>.

L<DBIx::Custom> is B<not< O/R mapper, O/R mapper is usefule, but
you must learn many things. Created SQL is sometimes inefficient,
and in many cases you create raw SQL because
O/R mapper can't make complex SQL

L<DBIx::Custom> is opposit of O/R mapper.
The main purpose is that we respect SQL
and make easy difficult works if you use only L<DBI>.
If you already learn SQL, it is easy to use L<DBIx::Custom>.

I explain L<DBIx::Custom> a little in this section.
In L<DBIx::Custom>, you embbed tag in SQL.

    select * from book where {= title} and {=author};

The part arround {} is tag.
This SQL is converted to the one which contains place holder.

    select * from book where title = ? and author = ?;

Maybe you ask me that this conversion is meaningful.
On the top of this, usuful features is implemented.
See the following descriptions.

=over 4

=item 1. Specify place holder binding value as hash refernce

If you use L<DBI>, you must specify place holder binding value
as array.

    $sth->execute(@bind);

If you use L<DBIx::Custom>, you specify it as hash reference.
    
    my $param = {title => 'Perl', author => 'Ken'};
    $dbi->execute($sql, $param);

=item 2. Filtering

L<DBIx::Custom> provides filtering system.
For example, You think that about date value you want to 
manipulate it as date object like L<Time::Piece> in Perl,
and want to convert it to database DATE format.
and want to do reverse.

You can use filtering system.

At first, register filter.

    $dbi->register_filter(
        tp_to_date => sub {
            ...
        },
        date_to_tp => sub {
            ...
        }
    );

next, apply this filter to each column.

    $dbi->apply_filter('book',
        'issue_date' => {out => 'tp_to_date', in => 'date_to_tp'}
    );

C<out> is perl-to-database way. C<in> is perl-from-database way.

This filter is automatically enabled in many method.

    $dbi->insert(table => 'book', param => {issue_date => $tp});


=item 3. Selective search condition

It is difficult to create selective where clause in L<DBI>.
For example, If C<title> and C<author> is specified, we create 
the following SQL.

    select * from book where title = ? and author = ?;

If only C<title> is specified, the following one

    select * from book where title = ?;

If only C<author> is specified, the following one,

    select * from book where author = ?;

This is hard work. Generally we use modules like L<SQL::Abstract>.
L<DBIx::Custom> prepare the way to make it easy.

    # Where object
    my $where = $dbi->where;
    
    # Search condition
    $where->clause(
        ['and', '{= title}', {'= author'}]
    );
    
    # Setting to automatically select needed column
    $where->param({title => 'Perl'});

    # Embbed where clause to SQL
    my $sql = "select * from book $where";

You can create where clause which has selected search condition.
You can write nesting of where clause and C<or> condition

=item 4. Methods for insert, update, delete, select

L<DBIx::Custom> provides methods for insert, update, delete, select
There are C<insert()>, C<update()>, C<delete()>,C<select()>.

    my $param = {title => 'Perl', author => 'Ken'};
    $dbi->insert(table => 'book', param => $param);

=item 5. Register method for table.

You can register method for table.

    $dbi->table('book')->method(
        list => sub {
            ...
        },
        something => sub {
            ...
        }
    );

use the mehtod.

    $dbi->table('book')->list;

Many O/R mapper must create class for table,
but L<DBIx::Custom> make it easy.

=back

L<DBIx::Custom> is very useful.
See the following if you are interested in it.

=head2 1. Connect to database

Load L<DBIx::Custom>.

    use DBIx::Custom;

use C<connect()> to connect to database.
Return value is L<DBIx::Custom> object.

    my $dbi = DBIx::Custom->connect(
        data_source => "dbi:mysql:database=bookstore",
        user => 'ken',
        password => '!LFKD%$&',
        dbi_options => {mysql_enable_utf8 => 1}
    );

C<data_source> must be one corresponding to the database system.
The following ones are data source example.

B<MySQL>

    "dbi:mysql:database=$database"
    "dbi:mysql:database=$database;host=$hostname;port=$port"

B<SQLite>

    "dbi:SQLite:dbname=$database"
    "dbi:SQLite:dbname=:memory:"

B<PostgreSQL>

    "dbi:Pg:dbname=$dbname"

B<Oracle>

    "dbi:Oracle:$dbname"
    "dbi:Oracle:host=$host;sid=$sid"

B<ODBC(Microsoft Access)>

    "dbi:ODBC:driver=Microsoft Access Driver (*.mdb);dbq=hoge.mdb"

B<ODBC(SQL Server)>

   "dbi:ODBC:driver={SQL Server};Server=(local);database=test;Trusted_Connection=yes;AutoTranslate=No;"

If authentication is needed, you can specify C<user> and C<password>

L<DBIx::Custom> is wrapper class of L<DBI>.
You can use all methods of L<DBI> from L<DBIx::Custom> object.

    $dbi->do(...);
    $dbi->begin_work;

use C<dhb()> to get database handle of L<DBI>

    my $dbh = $dbi->dbh;

By default, the following ones is set to database handle attributes.

    RaiseError  ->  1
    PrintError  ->  0
    AutoCommit  ->  1

If fatal error occuer, program terminate.
If SQL is executed, commit is executed automatically.

=head2 2. Methods for insert, update, delete, or insert

There are following methods.

=head3 C<insert()>

use C<insert()> to insert row into database

    $dbi->insert(table  => 'book',
                 param  => {title => 'Perl', author => 'Ken'});

C<table> is table name, C<param> is insert data.

Following SQL is executed.

    insert into (title, author) values (?, ?);

=head3 C<update()>

use C<update()> to update row in database.

    $dbi->update(table  => 'book', 
                 param  => {title => 'Perl', author => 'Ken'}, 
                 where  => {id => 5});

C<table> is table name, C<param> is update data, C<where> is condition.

Following SQL is executed.

    update book set title = ?, author = ?;

You can't execute C<update()> without C<where> for safety.
use C<update_all()> if you want to update all rows.

    $dbi->update_all(table  => 'book', 
                     param  => {title => 'Perl', author => 'Ken'});

=head3 C<delete()>

use C<delete()> to delete rows from database.

    $dbi->delete(table  => 'book',
                 where  => {author => 'Ken'});

C<table> is table name, C<where> is condition.

Following SQL is executed.

    delete from book where id = ?;

You can't execute C<delete()> without C<where> for safety.
use C<delete_all()> if you want to delete all rows.

    $dbi->delete_all(table  => 'book');

=head3 C<select()>

use C<select()> to select rows from database

    my $result = $dbi->select(table => 'book');

Following SQL is executed.

    select * from book;

Return value is L<DBIx::Custom::Result> object.
use C<fetch()> to fetch row.

    while (my $row = $result->fetch) {
        my $title  = $row->[0];
        my $author = $row->[1];
    }

See L<3. Fetch row/"3. Fetch row"> about L<DBIx::Custom::Result>.

Continue more examples.

    my $result = $dbi->select(
        table  => 'book',
        column => ['author',  'title'],
        where  => {author => 'Ken'}
    );

C<column> is column names, C<where> is condition.

Following SQL is executed.

    select author, title from book where author = ?;

Next example.

    my $result = $dbi->select(
        table    => ['book', 'rental'],
        where    => {'book.name' => 'Perl'},
        relation => {'book.id' => 'rental.book_id'}
    );

C<relation> is relation of tables. This is inner join.

Following SQL is executed.

    select * from book, rental where book.name = ? and book.id = rental.book_id;

Next example.

    my $result = $dbi->select(
        table  => 'book',
        where  => {author => 'Ken'},
        append => 'for update',
    );

C<append> is string appending to end of SQL.

Following SQL is executed.

    select * book where author = ? for update;

C<appned> is also used at C<insert()>, C<update()>, C<update_all()>
C<delete()>, C<delete_all()>, and C<select()>.

=head3 C<execute()> SQL

use C<execute()> to execute SQL

    $dbi->execute("select * from book;");

Process tag and execute SQL.

    $dbi->execute(
        "select * from book {= title} and {= author};"
        param => {title => 'Perl', author => 'Ken'}
    );

Following SQL is executed.

    select * from book title = ? and author = ?;

Values of title and author is embbdeded into placeholder.

See L<5. Tag/"5. Tag"> about tag.

You don't have to wirte last semicolon in C<execute()>. 

    $dbi->execute('select * from book');

=head2 3. Fetch row

Return value of C<select()> is L<DBIx::Custom::Result> object.
There are many methods to fetch row.

=head3 Fetch a row (array) C<fetch()>

use C<fetch()> to fetch a row and assign it into array reference.

    my $row = $result->fetch;

You can get all rows.

    while (my $row = $result->fetch) {
        my $title  = $row->[0];
        my $author = $row->[1];
    }

=head3 Fetch only first row (array) C<fetch_first()>

use C<fetch_first()> to fetch only first row.

    my $row = $result->fetch_first;

You can't fetch rest rows
because statement handle C<finish()> is executed.

=head3 Fetch rows (array) C<fetch_multi()>

use C<fetch_multi()> to fetch rows and assign it into
array reference which has array references as element.

    while (my $rows = $result->fetch_multi(2)) {
        my $title0   = $rows->[0][0];
        my $author0  = $rows->[0][1];
        
        my $title1   = $rows->[1][0];
        my $author1  = $rows->[1][1];
    }

Specify row count as argument.

You can get the following data.

    [
        ['Perl', 'Ken'],
        ['Ruby', 'Mark']
    ]

=head3 Fetch all rows (array) C<fetch_all>

use C<fetch_all()> to fetch all rows and assign it into
array reference which has array reference as element.

    my $rows = $result->fetch_all;

You can get the following data.

    [
        ['Perl', 'Ken'],
        ['Ruby', 'Mark']
    ]

=head3 Fetch a row (hash) C<fetch_hash()>

use C<fetch_hash()> to fetch a row and assign it into hash reference.

    while (my $row = $result->fetch_hash) {
        my $title  = $row->{title};
        my $author = $row->{author};
    }

=head3 Fetch only first row (hash) C<fetch_hash_first()>

use C<fetch_hash_first()> to fetch only first row
and assign it into hash reference.

    my $row = $result->fetch_hash_first;

You can't fetch rest rows
because statement handle C<finish()> is executed.

=head3 Fetch rows (hash) C<fetch_hash_multi()>

use C<fetch_hash_multi()> to fetch rows and
assign it into array reference which has hash references as element.

    while (my $rows = $result->fetch_hash_multi(5)) {
        my $title0   = $rows->[0]{title};
        my $author0  = $rows->[0]{author};
        my $title1  = $rows->[1]{title};
        my $author1 = $rows->[1]{author};
    }

Specify row count as argument.

You can get the following data.

    [
        {title => 'Perl', author => 'Ken'},
        {title => 'Ruby', author => 'Mark'}
    ]

=head3 Fetch all rows (hash) C<fetch_hash_all()>

use C<fetch_hash_all()> to fetch all rows and
assign it into array reference which has hash 
references as element.

    my $rows = $result->fetch_hash_all;

You can get the following data.

    [
        {title => 'Perl', author => 'Ken'},
        {title => 'Ruby', author => 'Mark'}
    ]

=head3 Statement handle C<sth()>

use <sth()> to get statement handle.

    my $sth = $result->sth;

=head2 4. Filtering

L<DBIx::Custom> provide value filtering. 
For example, You maybe want to convert L<Time::Piece> object to
database date format when register data into database.
and convert database date fromat to L<Time::Piece> object
when get data from database.

=head3 Register filter C<register_filter()>

use C<register_filter() to register filter.

    $dbi->register_filter(
        # Time::Piece object to DATE format
        tp_to_date => sub {
            my $date = shift;

            return '0000-00-00' unless $tp;
            return $tp->strftime('%Y-%m-%d');
        },
        
        # DATE to Time::Piece object
        date_to_tp => sub {
            my $date = shift;

            return if $date eq '0000-00-00';
            return Time::Piece->strptime($date, '%Y-%m-%d');
        },
    );

Registered filter is used by C<apply_filter()> or etc.

=head3 Apply filter C<apply_filter()>

use C<apply_filter()> to apply registered filter.

    $dbi->apply_filter('book',
        issue_date => {out => 'tp_to_date', in => 'date_to_tp'},
        first_issue_date => {out => 'tp_to_date', in => 'date_to_tp'}
    );

First argument is table name. Arguments after first argument are pairs of column
name and fitering rule. C<out> of filtering rule is filter which is used when data
is send to database. C<in> of filtering rule is filter which is used when data
is got from database. 

You can specify code reference as filter.

    issue_date => {out => sub { ... }, in => sub { ... }}

Applied filter become effective at insert()>, C<update()>, C<update_all()>,
C<delete()>, C<delete_all()>, C<select()>.

    my $tp = Time::Piece->strptime('2010/10/14', '%Y/%m/%d');
    my $result = $dbi->select(table => 'book', where => {issue_date => $tp});

When data is send to database, L<Time::Piece> object is converted
to database date format "2010-10-14"

When data is fetched, database date format is
converted to L<Time::Piece> object.

    my $row = $resutl->fetch_hash_first;
    my $tp = $row->{issue_date};

You can also use column name which contains table name.

    $dbi->select(
        table => 'book',
        where => {'book.issue_date' => $tp}
    );

=head3 Individual filter C<filter>

You can apply individual filter .
This filter overwrite the filter by C<apply_filter()>

use C<filter> option to apply individual filter
when data is send to database.
This option is used at C<insert()>, C<update()>,
C<update_all()>, C<delete()>, C<delete_all()>, C<select()>,
C<execute()>.

C<insert()> example:

    $dbi->insert(
        table => 'book',
        param => {issue_date => $tp, first_issue_date => $tp},
        filter => {issue_date => 'tp_to_date', first_issue_date => 'tp_to_date'}
    );

C<execute()> example:

my $sql = <<"EOS";
select YEAR(issue_date) as issue_year
from book
where YEAR(issue_date) = {? issue_year}
EOS
   
    my $result = $dbi->execute(
        $sql,
        param => {issue_year => '2010'},
        filter => {issue_year => 'tp_to_year'}
    );

You can also apply indivisual filter when you fetch row.
use C<DBIx::Custom::Result>'s C<filter()>.

    $result->filter(issue_year => 'year_to_tp');

=head3 End filtering : C<end_filter()>

You can add filter at end.
It is useful to create last output.
use C<end_filter()> to add end filter.

    $result->end_filter(issue_date => sub {
        my $tp = shift;
        
        return '' unless $tp;
        return $tp->strftime('%Y/%m/%d %h:%m:%s (%a)');
    });

In this example, L<Time::Piece> object is converted to readable format.

=head3 Automate applying filter C<each_column()>

It is useful to apply filter automatically at date type columns.
You can use C<each_column()> to process all column infos.

    $dbi->each_column(
        sub {
            my ($self, $table, $column, $info) = @_;
            
            my $type = $info->{TYPE_NAME};
            
            my $filter = $type eq 'DATE'     ? {out => 'tp_to_date', in => 'date_to_tp'}
                       : $type eq 'DATETIME' ? {out => 'tp_to_datetime', in => 'datetime_to_tp'}
                                             : undef;
            
            $self->apply_filter($table, $column, $filter)
              if $filter;
        }
    );

C<each_column() receive callback.
callback arguments are L<DBIx::Custom> object, table name, column name, column information.
Filter is applied automatically by column type.

=head2 5. Tag

=head3 Basic of Tag

You can embedd tag into SQL.

    select * from book where {= title} and {like author};

{= title} and {like author} are tag. Tag has the folloring format.

    {TAG_NAME ARG1 ARG2 ...}

Tag start C<{> and end C<}>. 
Don't insert space between C<{} and tag name.

C<{> and C<}> are reserved word.
If you want to use these, escape it by '\';

    select from book \\{ ... \\}

\ is perl's escape character, you need two \.

C<\>自体がPerlのエスケープ文字ですので、
C<\>は二つ必要になります。

Tag is expanded before executing SQL.

    select * from book where title = ? and author like ?;

use C<execute()> to execute SQL which contains tag

    my $sql = "select * from book where {= author} and {like title};"
    $dbi->execute($sql, param => {title => 'Perl', author => '%Ken%'});

You can specify values embedded into place holder as hash reference using
C<param> option.

You can specify C<filter()> at C<execute()>.

    $dbi->execute($sql, param => {title => 'Perl', author => '%Ken%'}
                  filter => {title => 'to_something');

Note that at C<execute()> the filter applied by C<apply_filter()>
don't has effective to columns.
You need specify C<table> to have effective.

    $dbi->execute($sql, param => {title => 'Perl', author => '%Ken%'}
                  table => ['book']);

=head3 Tag list

L<DBIx::Custom>では次のタグが使用可能です。

The following tag is available.

=head4 C<?>

    {? NAME}    ->   ?

=head4 C<=>

    {= NAME}    ->   NAME = ?

=head4 C<E<lt>E<gt>>

    {<> NAME}   ->   NAME <> ?

=head4 C<E<lt>>

    {< NAME}    ->   NAME < ?

=head4 C<E<gt>>

    {> NAME}    ->   NAME > ?

=head4 C<E<gt>=>

    {>= NAME}   ->   NAME >= ?

=head4 C<E<lt>=>

    {<= NAME}   ->   NAME <= ?

=head4 C<like>

    {like NAME}   ->   NAME like ?

=head4 C<in>

    {in NAME COUNT}   ->   NAME in [?, ?, ..]

=head4 C<insert_param>

    {insert_param NAME1 NAME2}   ->   (NAME1, NAME2) values (?, ?)

=head4 C<update_param>

    {update_param NAME1 NAME2}   ->   set NAME1 = ?, NAME2 = ?

=head3 Manipulate same name's columns

It is ok if there are same name's columns.
Let's think two date comparison.

    my $sql = "select * from table where {> date} and {< date};";

In this case, You specify paramter values as array reference.

    my $dbi->execute($sql, param => {date => ['2010-10-01', '2012-02-10']});

=head3 Register Tag C<register_tag()>

You can register your tag.
use C<register_tag()> to register tag.

    $dbi->register_tag(
        '=' => sub {
            my $column = shift;
            
            return ["$column = ?", [$column]];
        }
    );

ここではデフォルトのC<=>タグがどのように実装されているかを示しています。
タグを登録する関数の引数はタグの中に書かれた引数になります。

    {タグ名 引数1 引数2}

C<=>タグの場合は

    {= title}

という形式ですから、サブルーチンにはtitleというひとつの列名がわたってきます。

サブルーチンの戻り値には次の形式の配列のリファレンスを返す必要があります。

    [
        展開後の文字列,
        [プレースホルダに埋め込みに利用する列名1, 列名2, ...]
    ]

一つ目の要素は展開後の文字列です。この例では

    'title = ?'

を返す必要があります。

二つ目の要素はプレースホルダに埋め込みに利用する列名を含む配列の
リファレンスです。今回の例では

    ['title']

を返す必要があります。複数のプレースホルダを含む場合は、この部分が
複数になります。C<insert_param>タグやC<update_param>タグは
この部分が実際複数になっています。

上記を合わせると

    ['title = ?', ['title']]
    
を返す必要があるということです。

タグの実装の他のサンプルはL<DBIx::Custom::Tag>のソースコード
をご覧になってみてください。

=head2 6. Where句の動的な生成

=head3 Where句の動的な生成 where()

複数の検索条件を指定して、検索を行いたい場合があります。
次の3つのケースのwhere句を考えてみましょう。
下記のようなwhere句が必要になります。

titleの値だけで検索したい場合

    where {= title}

authorの値だけで検索したい場合

    where {= author}

titleとauthorの両方の値で検索したい場合

    where {= title} and {=author}

L<DBIx::Custom>では動的なWhere句の生成をサポートしています。
まずC<where()>でL<DBIx::Custom::Where>オブジェクトを生成します。

    my $where = $dbi->where;

次にC<clause()>を使用してwhere句を記述します。

    $where->clause(
        ['and', '{= title'}, '{= author}']
    );

clauseの指定方法は次のようになります。

    ['or' あるいは 'and', タグ1, タグ2, タグ3]

第一引数にはorあるいはandを指定します。第二引数以降には
検索条件をタグを使って記述します。

C<clause>の指定は入れ子にすることもでき、さらに複雑な条件
を記述することもできます。

    ['and', 
      '{= title}', 
      ['or', '{= author}', '{like date}']
    ]

このようにC<clause>を設定した後にC<param>にパラメータを指定します。
    
    my $param => {title => 'Perl'};
    $where->param($param);

この例ではtitleだけがパラメータに含まれています。

この後C<to_string()>を実行すると$paramに含まれるパラメータを満たす
where句を生成することができます。

    my $where_clause = $where->to_string;

パラメータはtitleだけですので、次のようなwhere句が生成されます。

    where {= title}

またL<DBIx::Custom>は文字列の評価をオーバーロードして、C<to_string()>
を呼び出すようにしていますので、次のようにしてwhere句を生成することも
できます。

    my $where_clause = "$where";

これはSQLの中にwhere句を埋め込むときにとても役立つ機能です。

=head3 同一の列名を含む場合

タグの中に同一の名前を持つものが存在した場合でも動的に
where句を作成することができます。

たとえば、パラメータとして開始日付と終了日付を受け取ったことを
考えてみてください。

    my $param = {start_date => '2010-11-15', end_date => '2011-11-21'};

また開始日付と終了日付の片方だけや、どちらも受け取らない場合もあるかもしれません。

この場合は次のようなパラメータに変換することで対応することができます。

    my $p = {date => ['2010-11-15', '2011-11-21']};

値が配列のリファレンスになっていることに注目してください。このようにすれば
同名の列を含むタグに順番に埋め込むことができます。

    $where->clause(
        ['and', '{> date}', '{< date}']
    );
    $where->param($p);

また開始日付が存在しない場合は次のようなデータを作成します。

    my $p = {date => [$dbi->not_exists, '2011-11-21']};

L<DBIx::Custom>のC<not_exists>でDBIx::Custom::NotExistsオブジェクトを
取得できます。これは対応する値が存在しないことを示すためのものです。

また終了日付が存在しない場合は次のようなデータを作成します。

    my $p = {date => ['2010-11-15']};

どちらも存在しない場合は次のようなデータを作成します。

    my $p = {date => []};

少し難しいので一番簡単に作成できるロジックを示しておきます。

    my @date;
    push @date, exists $param->{start_date} ? $param->{start_date}
                                            : $dbi->not_exists;
    push @date, $param->{end_date} if exists $param->{end_date};
    my $p = {date => \@date};

=head3 C<select()>との連携

L<DBIx::Custom::Where>オブジェクトは
C<select()>のC<where>に直接渡すことが
できます。
    
    my $where = $dbi->where;
    $where->clause(...);
    $where->param($param);
    my $result = $dbi->select(table => 'book', where => $where);

あるいはC<update()>、C<delete()>のwhereに指定することも可能です。

=head3 C<execute()>との連携

C<execute()>との連携です。SQLを作成するときに埋め込むことができます。


    my $where = $dbi->where;
    $where->clause(...);
    $where->param($param);

    my $sql = <<"EOS"
    select * from book;
    $where
    EOS

    $dbi->execute($sql, param => $param);

=head2 7. テーブルモデル

=head3 テーブルオブジェクトの作成 C<table()>

L<DBIx::Custom>はロジックとしてテーブルを中心にすえた
モデルの作成を支援します。

アプリケーションのロジックを記述するときに、そのロジックを
データベースのテーブルにすえることは、RDBMSを利用する
モデルであれば、コードの重複も少なく
わかりやすいものになります。

テーブルオブジェクトを生成するにはC<table()>を使用します。

    my $table = $dbi->table('book');

実際にデータベースにテーブルは存在している必要はありません。
これは仮想的なテーブルオブジェクトです。これは
L<DBIx::Customm::Table>オブジェクトになります。

テーブルオブジェクトからはC<insert()>、C<update()>、C<update_all()>、
C<delete()>、C<delete_all()>、C<select()>などのメソッド呼び出すことができます。
L<DBIx::Custom>と異なるところは、C<table>を必ずしも指定する必要が
ないということです。

    $table->insert(param => $param);

C<table＞の値は自動的にbookに設定されます。

またテーブルオブジェクトには独自のメソッドを追加することができます。

    $table->method(
        register => sub {
            my $self = shift;
            my $table_name = $self->name;
            # something
        },
        list => sub {
            my $self = shift;
            my $table_name = $self->name;
            # something
        }
    );

メソッドに渡される第一引数はL<DBIx::Custom::Table>オブジェクトです。
C<name()>を使用して、テーブル名を取得することができます。

このようにして登録したメソッドは直接呼び出すことができます。

    $table->register(...);
    $table->list(...);

またテーブル専用のメソッドをオーバーライドして作成することもできます。

    $table->method(
        insert => sub {
            my $self = shift;
            
            $self->base_insert(...);
            
            # something
        }
    );

もともと存在していたC<insert()>を呼ぶにはC<base_$method>とします。L<DBIx::Custom::Table>
のオーバーライドの機能は簡易的なものですが、とても便利です。

=head2 テーブルで共有のメソッドの登録

すべてのテーブルでメソッドを共有するにはC<table>メソッドでテーブルを作成する前に、
C<base_table>にメソッドを登録しておきます。

    $dbi->base_table->method(
        count => sub {
            my $self = shift;
            return $self->select(column => ['count(*)']);
        }
    );

またテーブルからはL<DBIx::Custom>とL<DBI>のすべてのメソッドを呼び出すことができます。

    # DBIx::Custom method
    $table->execute($sql);
    
    # DBI method
    $table->begin_work;
    $table->commit;

=head2 一般的なモデルの構成

一般的には、L<DBIx::Custom>を継承してコンストラクタの中に、モデルを作成
するのがよいでしょう。

    package MyDBI;
    
    use base 'DBIx::Custom';
    
    sub connect {
        my $self = shift->SUPER::connect(@_);
        
        $self->base_table->method(
            ... => sub { ... }
        );
        
        $self->table('book')->method(
            insert_multi => sub { ... },
            ... => sub { ... }
        );
        
        $self->table('company')->method(
            ... => sub { ... },
        );
    }

このようにして定義しておけば、次のように利用することができます。

    my $dbi = MyDBI->connect(...);
    $dbi->table('book')->insert_multi(...);

=head2 8. パフォーマンスの改善

=head3 クエリの作成

もしC<insert()>メソッドを使用してインサートを実行した場合、
必要なパフォーマンスを得られない場合があるかもしれません。
C<insert()>メソッドは、SQL文とステートメントハンドルを
毎回作成するためです。

そのような場合は、C<query>オプションを指定することで、
クエリを取得することができます。

    my $query = $dbi->insert(table => 'book', param => $param, query => 1);

またC<create_query()>メソッドを使って任意のSQLのクエリを作成
することもできます。

    my $query = $dbi->create_query(
        "insert into book {insert_param title author};";
    );

戻り値はL<DBIx::Custom::Query>オブジェクトです。
このオブジェクトはSQL文とパラメータバインド時の列名を
保持しています。またステートメントハンドルも保持しています。

    {
        sql     => 'insert into book (title, author) values (?, ?);',
        columns => ['title', 'author'],
        sth     => $sth
    }

クエリオブジェクトを使って繰り返し実行するにはC<execute()>を使用します。
    
    my $params = [
        {title => 'Perl',      author => 'Ken'},
        {title => 'Good days', author => 'Mike'}
    ];
    
    foreach my $param (@$paramss) {
        $dbi->execute($query, table => 'book', param => $input);
    }

C<execute>メソッドの第一引数にクエリオブジェトを渡すことができます。
C<insert()>メソッドよりも高速です。

注意点がいくつかあります。それはパラメータの数は必ず同じでなくてはならない
ということです。最初に3つのパラメータだけを渡したのに、次の実行では
二つのパラメータを渡すと予期しない結果になります。それは
動的に生成されたSQLに含まれるプレースホルダの数が異なるからです。
またC<execute()>によっては自動的にはフィルタが有効にならないので、
C<table>を指定する必要のあることに注意してください。
本当に必要な場合だけ利用してください。

=head2 9. その他の機能

=head3 メソッドの登録

メソッドを登録するにはC<method()>を使用します。

    $dbi->method(
        update_or_insert => sub {
            my $self = shift;
            # something
        },
        find_or_create   => sub {
            my $self = shift;
            # something
        }
    );

<method()>で登録したメソッドは
L<DBIx::Custom>オブジェクトから直接呼び出すことができます。

    $dbi->update_or_insert;
    $dbi->find_or_create;

=head3 結果クラスの変更

必要ならば結果クラスを変更することができます。

    package MyResult;
    use base 'DBIx::Custom::Result';
    
    sub some_method { ... }

    1;
    
    package main;
    
    use MyResult;
    
    my $dbi = DBIx::Custom->connect(...);
    $dbi->result_class('MyResult');

=head3 キャッシング

タグの展開後のSQLはパフォーマンスの理由のためにキャッシュされます。
これはC<chace>で設定でき、デフォルトではキャッシュを行う設定です。

    $dbi->cache(1);

キャッシュ方法はC<cache_method>にメソッドを指定することで
変更することができます。
データの保存と取得のためのメソッドを定義します。

デフォルトでは次のようにメモリ上にキャッシュを行うものになっています。

    $dbi->cache_method(sub {
        sub {
            my $self = shift;
            
            $self->{_cached} ||= {};
            
            if (@_ > 1) {
                # Set
                $self->{_cached}{$_[0]} = $_[1] 
            }
            else {
                # Get
                return $self->{_cached}{$_[0]}
            }
        }
    });
    
第一はL<DBIx::Custom>オブジェクトです。
第二引数はタグの展開される前のSQLです。
第三引数はタグの展開後のSQLです。

自分で作成する場合は第三引数が存在した場合はキャッシュを設定し、
存在しなかった場合はキャッシュを取得する実装に
してください。

=cut

=head1 EXAMPLES

L<DBIx::Custom Wiki|https://github.com/yuki-kimoto/DBIx-Custom/wiki> - Many useful examples

=cut
